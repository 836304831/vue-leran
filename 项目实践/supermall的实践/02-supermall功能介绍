
功能介绍

1. FeatureView的封装
    独立组件封装FeatureView
        - div -> img

2. TabControl封装
    独立组件的封装
        - props -> titles
        - div -> 根据titles v-for 遍历div->span
        - css 相关
        - 选用哪一个tab，哪一个tab的文件颜色改变，下面加上border-botton
            - 使用currentIndex判断当前指向哪一个tab

3. 首页商品数据的请求
    3.1 设计数据结构，用于保存数据，将Home.vue
    3.2 发送数据请求：见 network目录

4. 对商品数据进行展示
    4.1 封装GoodList.vue组件
    4.2 封装GoodListItem.vue组件

5. 对滚进行重构，使用beter-scroll
    5.1 对BackTop.vue组件进行封装，使用见18-补充
    5.2 在Vue项目中使用better-scroll，见home.vue

6. 回到顶部BackTop
    6.1 对BackTop.vue组件的封装
    6.2 如何监听组件的点击
        直接监听back-top的点击，监听是必须添加修饰符.native
        回到顶部
            - scrool对象，scrool.scrollTo(x, y, time)
            - this.$ref.scroll.scrollTo(0, 0, 500)
    6.3 BackTop组件的显示和隐藏
        isShowBackTop: false
        监听滚动，拿到滚动的位置
            - -position > 1000 —> isShowBackTop: true
            - isShowBackTop = -position.y > 1000

7. 解决首页中可滚动区域的问题（图片加载延迟导致）
    7.1 better-scroll在决定有多少区域可以滚动时，是根据scrollHeight属性巨顶
        - scrollHeight属性是放Better-scroll的content中的子组件的高度
        - 但在首页中，刚开始计算scrollHeight属性时，因为图片的延迟加载，没有将图片计算在内，导致计算的结果是错误的
        - 图片加载后有了新的高度，但scrollHeight属性值没有更新，导致滚动出现问题
    7.2 解决滚动出现不正确的问题
        - 监听每一张图片是否加载完成，一旦有图片加载完成，执行一个scroll.refresh，触发重新计算scrollHeight
        - 监听图片加载完成
            - 原生的js监听图片：img.onload=function() {}
            - Vue中监听，@load=”方法“
        调用scroll.refresh,触发计算scrollHeight
    7.3 如何见goodsListItem.vue中的事件传入Home.vue（非父子组件通讯）
        - 非父子组件通讯，次奥也能够事件总线
            - bus->总线
            - Vue.prototype.$bus=new Vue（）
            - this.bus.emit("事件名称", 参数)
            - this.bus.on("事件名称", 回调函数(参数))
    7.4 refresh找不到问题
        - 在scroll.vue中，调用this.scroll方法之前，判断this.scroll对象是否有值
        - 在mounted生命周期函数中使用this.$refs.scrool而不是定义在created中
    7.5 对于refresh调用非常频繁，影响性能，需要进行防抖操作
        - 防抖debounce/节流throttle
        - 防抖函数起作用过程
            - 如果我们直接执行refresh,那么refresh函数会加载一张图片执行一次
            - 可以将refresh函数传入debounce函数，生成一个新的函数
            - 之后在调用非常频繁的时候，就使用新生成的函数
            - 新生成的函数并不会频繁的带哦用，如果下一次执行的非常快，那么会见上一次取消掉

8. 上来加载更多功能实现

9. tabControl的吸顶效果
    9.1 获取tabControl的off
        必须知道滚动到多少时，开始有吸顶效果，这个时候需要获取tabControl的offsetTop
        若直接在mounted中获取tabControl的offsetTop，那么值是不正确的
        解决方法（也可以在监听所有图片加载完成，多次获取tabControl的offsetTop）：
            监听HomeSwiper中img加载完成事件
            加载完成后，发出事件，在home.vue中，再去获取tabControl的offsetTop
    9.2 监听滚动，动态的改变tabControl的样式
        问题：动态改变tabControl的样式时出现两个问题
            问题1：下面的商品内容，会突然上衣
            问题2：tabControl虽然设置了fixed，但是也会随着better scroll一起滚出去
        解决方案：
            - 在最上面，多复制一份PlaceHolder tabControl组件对象，利用它实现停留效果
            - 当用户鼓捣弄到一定位置时，PlaceHolder tabControl组件就显示出来
            - 但用户滚动达到一定位置时，PlaceHolder tabControl组件隐藏起来

10. 让Home在切换到其他tab-bar之后在切换回来依然保持原来的状态
    10.1 让Home不要销毁掉
        使用keep-alive（将App.vue）
            <keep-alive>
              <router-view/>
            </keep-alive>
    10.2 让Home中的内容保持原来的位置(见Home.vue)
        离开时，保存一个位置信息SaveY
        进来时，将位置设置为原来保存的saveY即可（）
            activated() {
              console.log('actived');
              this.$refs.scrol.scrollTo(0, -this.saveY, 0)
              this.$refs.scroll.refresh()
            },
            deactivated() {
              this.saveY = this.$refs.scroll.getScrollY()
              console.log(this.saveY);
            }
